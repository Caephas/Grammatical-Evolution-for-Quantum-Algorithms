# BNF Grammar for 2-Qubit Circuit with Oracle Placeholder (Qiskit-like)

## Overview

This document defines a Backus–Naur Form (BNF) grammar that specifies the structure of a 2-qubit quantum circuit framework. The circuit generated by this grammar is typical for quantum algorithms that evaluate a function \(f: \{0,1\} \rightarrow \{0,1\}\) using an oracle, such as the Deutsch–Jozsa algorithm (for \(n=1\)) or the Bernstein–Vazirani algorithm (for \(n=1\)).

The grammar generates Python code intended for use with quantum computing frameworks like Qiskit. It establishes a specific structure:

1. Initialization of a 2-qubit (1 input, 1 ancilla) and 1-classical-bit circuit.  
2. An initial sequence preparing the input and ancilla qubits.  
3. An optional barrier.  
4. A placeholder comment indicating where the Oracle implementation should be inserted.  
5. An optional barrier.  
6. A final setup sequence acting on the input qubit.  
7. Measurement of the input qubit.  

> **Note:** The grammar defines the *framework* around the oracle but **does not** define the oracle itself. It inserts a placeholder comment `# ORACLE_INSERTION_POINT` where the specific oracle logic (e.g., implementing an XOR function via CNOT gates) would need to be added subsequently.

---

## Grammar Definition

```bnf
<Program>                ::=
    <Initialize>
    <InitialSetupSequence>
    <OptionalBarrier>
    <OraclePlaceholder>
    <OptionalBarrier>
    <FinalSetupSequence>
    <Measure>

<Initialize>             ::=
    "qc = QuantumCircuit(2, 1)\n"

<InitialSetupSequence>   ::= <InitialSetupStep1> <InitialSetupStep2> <InitialSetupStep3>
<InitialSetupStep1>      ::= "qc.x(1)\n" | <SingleQubitGateOnAncilla>
<InitialSetupStep2>      ::= "qc.h(1)\n" | <SingleQubitGateOnAncilla>
<InitialSetupStep3>      ::= "qc.h(0)\n" | <SingleQubitGateOnInput>

<FinalSetupSequence>     ::= <FinalSetupStep>
<FinalSetupStep>         ::= "qc.h(0)\n" | <SingleQubitGateOnInput>

<Measure>                ::=
    "qc.measure(0, 0)\n"

<OraclePlaceholder>      ::=
    "# ORACLE_INSERTION_POINT\n"

<OptionalBarrier>        ::=
      ""
    | "qc.barrier()\n"

<SingleQubitGateOnInput> ::=
    "qc.x(0)\n"
  | "qc.h(0)\n"
  | "qc.s(0)\n"
  | "qc.sxdg(0)\n"       # Square-root X dagger gate
  | "qc.t(0)\n"
  | "qc.tdg(0)\n"
  | "qc.rx(pi/2, 0)\n"   # Assumes `pi` is defined
  | "qc.ry(pi/4, 0)\n"   # Assumes `pi` is defined
  | "qc.p(pi/4, 0)\n"    # Phase gate, assumes `pi` is defined
  | "qc.u1(pi/3, 0)\n"   # Deprecated U1 gate, assumes `pi` is defined

<SingleQubitGateOnAncilla> ::=
    "qc.x(1)\n"
  | "qc.h(1)\n"
  | "qc.s(1)\n"
  | "qc.sxdg(1)\n"
  | "qc.t(1)\n"
  | "qc.tdg(1)\n"
  | "qc.rx(pi/2, 1)\n"
  | "qc.ry(pi/4, 1)\n"
  | "qc.p(pi/4, 1)\n"
  | "qc.u1(pi/3, 1)\n"




Explanation of Components
 • <Program>: The root element, defining the complete sequence for the circuit framework.
 • <Initialize>: Sets up a QuantumCircuit object named qc with 2 quantum bits (qubit 0 as input, qubit 1 as ancilla) and 1 classical bit.
 • <InitialSetupSequence>: Three gate operations applied before the oracle.
 • <InitialSetupStep1> & <InitialSetupStep2>: Gates on the ancilla (1).
 • <InitialSetupStep3>: Gate on the input (0).
 • <FinalSetupSequence>: Single gate on the input qubit (0) after the oracle placeholder.
 • <Measure>: Measures input qubit 0 into classical bit 0.
 • <OraclePlaceholder>: Inserts the comment # ORACLE_INSERTION_POINT, marking where to add the oracle logic.
 • <OptionalBarrier>: Optionally adds qc.barrier() before/after the oracle placeholder or nothing.
 • Gate Rules:
 • <SingleQubitGateOnInput> / <SingleQubitGateOnAncilla> define alternative preparation gates.
 • Parameterized gates assume pi is defined (e.g., import numpy as np; pi = np.pi).


Key Features and Constraints
 • Fixed Size: 2-qubit system (1 input, 1 ancilla) + 1 classical bit.
 • Qiskit Syntax: Uses Qiskit’s Python API conventions.
 • Oracle Framework: Supplies setup and measurement around—but not including—the oracle.
 • Placeholder: # ORACLE_INSERTION_POINT marks where oracle code goes.
 • Flexible Setup: Allows varied gates for state preparation.
 • Optional Barriers: Improves circuit clarity.
 • Targeted Measurement: Only measures the input qubit.
 • pi Dependency: Parameterized gates require pi defined externally.

```bnf
Example Snippet Structure (Illustrative)

# Assume: from qiskit import QuantumCircuit
# Assume: import numpy as np; pi = np.pi

# <Initialize>
qc = QuantumCircuit(2, 1)

# <InitialSetupSequence>
qc.x(1)        # Step 1
qc.h(1)        # Step 2
qc.h(0)        # Step 3

# <OptionalBarrier>
qc.barrier()

# <OraclePlaceholder>
# ORACLE_INSERTION_POINT

# <OptionalBarrier> (omitted)

# <FinalSetupSequence>
qc.h(0)

# <Measure>
qc.measure(0, 0)
# After generation, replace "# ORACLE_INSERTION_POINT" with:
# e.g., qc.cx(0, 1)  # Implements XOR oracle f(x) = x
```
