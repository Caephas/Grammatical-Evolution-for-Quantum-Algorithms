# BNF Grammar for 3-Qubit Grover's Algorithm (Qiskit-like Syntax)

## Overview

This document defines a Backus–Naur Form (BNF) grammar that specifies the structure of a quantum circuit implementing Grover’s search algorithm for a 3-qubit system. The output generated by following this grammar is Python code intended for use with quantum computing frameworks like Qiskit, although direct compatibility requires importing necessary libraries (`QuantumCircuit`, `numpy as np`).

The grammar enforces a specific structure:

1. Initialization of a 3-qubit quantum circuit.  
2. Application of Hadamard gates to all qubits.  
3. A sequence of Grover iterations, each consisting of an Oracle *or* a Diffuser block.  
4. Measurement of all qubits.  

> **Note:** The rule  
>
> ```bnf
> <GroverIteration> ::= <OracleBlock> | <DiffuserBlock>
> ```  
>
> means that a single "iteration" in the generated sequence consists of **either** an Oracle **or** a Diffuser, not necessarily the standard paired Oracle–Diffuser structure. Valid sequences include `Oracle, Diffuser, Oracle, Diffuser…` as well as `Oracle, Oracle, Diffuser, Diffuser…`.

---

## Grammar Definition

```bnf
<Program>           ::= <Initialize> <HadamardAll> <GroverIterations> <Measure>

<Initialize>        ::= "qc = QuantumCircuit(3, 3)\n"

<HadamardAll>       ::=
    "qc.h(0)\n"
    "qc.h(1)\n"
    "qc.h(2)\n"

<GroverIterations>  ::= <GroverIteration>
                     | <GroverIteration> <GroverIterations>

<GroverIteration>   ::= <OracleBlock> | <DiffuserBlock>

<OracleBlock>       ::= "## Begin Oracle\n"
                       <OptionalOracleVariations>
                       "## End Oracle\n"

<OptionalOracleVariations> ::= <SmallGateList>

<SmallGateList>     ::= <SmallGate>
                     | <SmallGate> <SmallGateList>

<SmallGate>         ::= <SingleQubitGate>
                     | <TwoQubitGate>
                     | <ThreeQubitGate>
                     | <ParameterizedGate>

<DiffuserBlock>     ::= "## Begin Diffuser\n"
                       <StandardDiffuser>
                       <OptionalGates>
                       "## End Diffuser\n"

<StandardDiffuser>  ::=
    "qc.h(0)\n"
    "qc.h(1)\n"
    "qc.h(2)\n"
    "qc.x(0)\n"
    "qc.x(1)\n"
    "qc.x(2)\n"
    "qc.h(2)\n"
    "qc.cx(0,2)\n"       # Note: this uses CX gates targeting qubit 2
    "qc.cx(1,2)\n"
    "qc.h(2)\n"
    "qc.x(0)\n"
    "qc.x(1)\n"
    "qc.x(2)\n"
    "qc.h(0)\n"
    "qc.h(1)\n"
    "qc.h(2)\n"

<OptionalGates>     ::= <GateList>

<GateList>          ::= <Gate>
                     | <Gate> <GateList>

<Gate>              ::= <SingleQubitGate>
                     | <TwoQubitGate>
                     | <ThreeQubitGate>
                     | <ParameterizedGate>

<SingleQubitGate>   ::=
    "qc.x(" <QubitSingle> ")\n"
  | "qc.y(" <QubitSingle> ")\n"
  | "qc.z(" <QubitSingle> ")\n"
  | "qc.h(" <QubitSingle> ")\n"
  | "qc.s(" <QubitSingle> ")\n"
  | "qc.sdg(" <QubitSingle> ")\n"
  | "qc.t(" <QubitSingle> ")\n"
  | "qc.tdg(" <QubitSingle> ")\n"
  | "qc.id(" <QubitSingle> ")\n"

<TwoQubitGate>      ::=
    "qc.cx(" <TwoDistinctQubits> ")\n"
  | "qc.cy(" <TwoDistinctQubits> ")\n"
  | "qc.cz(" <TwoDistinctQubits> ")\n"
  | "qc.swap(" <TwoDistinctQubits> ")\n"
  | "qc.iswap(" <TwoDistinctQubits> ")\n"

<ThreeQubitGate>    ::=
    "qc.ccx(" <ThreeDistinctQubits> ")\n"  # Toffoli gate
  | "qc.cswap(" <ThreeDistinctQubits> ")\n"  # Fredkin gate

<ParameterizedGate> ::=
    "qc.rx(" <Angle> "," <QubitSingle> ")\n"
  | "qc.ry(" <Angle> "," <QubitSingle> ")\n"
  | "qc.rz(" <Angle> "," <QubitSingle> ")\n"
  | "qc.u(" <Angle> "," <Angle> "," <Angle> "," <QubitSingle> ")\n"
  | "qc.rxx(" <Angle> "," <TwoDistinctQubits> ")\n"
  | "qc.ryy(" <Angle> "," <TwoDistinctQubits> ")\n"
  | "qc.rzz(" <Angle> "," <TwoDistinctQubits> ")\n"
  | "qc.rzx(" <Angle> "," <TwoDistinctQubits> ")\n"

<QubitSingle>       ::= "0" | "1" | "2"

<TwoDistinctQubits> ::=
    "0,1" | "1,0"
  | "0,2" | "2,0"
  | "1,2" | "2,1"

<ThreeDistinctQubits> ::=
    "0,1,2" | "0,2,1"
  | "1,0,2" | "1,2,0"
  | "2,0,1" | "2,1,0"

<Angle>             ::=
    "0"
  | "np.pi/4"
  | "np.pi/2"
  | "np.pi"
  | "3*np.pi/2"
  | "2*np.pi"
  | "0.5"
  | "1.3"
  | "2.7"
  | "0.314"
  | "1.5708"
  | "3.1415"

<Measure>           ::=
    "qc.measure(0, 0)\n"
    "qc.measure(1, 1)\n"
    "qc.measure(2, 2)\n"
